<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>About Me</title><url>/about/</url><categories/><tags/><content type="html"> 低段位小码农一枚，黑发尚在，肚腩已起。在变成油腻中年老大叔的道上一路狂奔。
思想上的矮子，行动上的侏儒。
初酢酒，不胜酒力，恶其味灼，但喜微醺。
不要给我谈理想，我的理想是不上班。何以解忧，唯有暴富。</content></entry><entry><title>如何结算指定时区的订单</title><url>/program/how-to-settle-order-with-time-zone/</url><categories><category>编程</category></categories><tags><tag>timestamp</tag></tags><content type="html"><![CDATA[  如果程序需要根据指定时区来处理某些业务，即服务器端要有时区概念。则有没有一套比较好的方案。
例如电商系统，以东京时间凌晨两点结算过去一天的订单总量。服务器默认时区是北京时区，数据库存储的是长整型毫秒级时间戳。
通用规范 如果需要处理的时间是当前和未来的时间，则使用长整型毫秒级时间戳进行存储和计算。
遵循存储与显示分离的策略。服务端存储整型时间戳，客户端显示格式化结果。
如：用户创建一笔订单，服务器以自己的时间为基准生成长整型毫秒级时间戳作为该笔订单的创建时间，然后存入数据库。用户查看该笔订单时，服务器从数据库中取出该笔订单并返回，客户端根据所在时区格式化成指定时间格式。
探索方案 先给出一个公式：
指定日期时间 - 偏移量 - 绝对起始时间常量 = 时间戳
xxxx年xx日xx时xx分xx秒 - 偏移几个小时如+8:00 - 1970年01月01日00时00分00秒 = 时间戳 除去绝对起始时间常量外，已知任意两个变量可以求出第三个变量
考虑，东京时间的2019年8月15日当天的时间戳范围是多少，与北京时间的2019年8月15日的时间戳范围是一样的吗？
//东京2019年8月15日0时0分0秒的时间戳： ZonedDateTime.parse(&#34;2019-08-15T00:00:00.000+09:00&#34;).toInstant().toEpochMilli(); //得出 1565794800000 //北京2019年8月15日0时0分0秒的时间戳： ZonedDateTime.parse(&#34;2019-08-15T00:00:00.000+08:00&#34;).toInstant().toEpochMilli(); //得出 1565798400000 可以看出，两个不同时区的起始时间的时间戳是不同的。可以想象，不论用哪个时区，只要时间过一毫秒，时间戳就加1。而东京先看到太阳，此刻时间戳为a。而北京要过一小时后才看到太阳，此刻时间戳记为b。而a加一小时才等于b，所以a要比b小。
结论：同一个本地时间，时区偏移量越大的，其时间戳越小。
经过上面的讨论。可以形成一个思路去解决上面遇到的问题：
使用cron表达式，指定时区指定时间执行任务。
任务开始，计算东京时间2019年8月15日0时0分0秒的时间戳作为起始时间，计算东京时间2019年8月15日23点59分59秒的时间戳作为终止时间。扫描表中创建时间在这两个范围内的订单。则扫描到的订单均为东京时间2019年8月15日生成的。
注意点 此类逻辑处理完全依赖于业务是否考虑使用指定时区。如果不指定，则默认使用服务器的本地时可以解决。如果指定，则需要完整的考虑时区问题。
如果业务有时区问题，需要发布公告完善的指明业务支持的时区问题，规避非指定时区的人使用服务时造成的困扰。
  ]]></content></entry><entry><title>邮件防伪造</title><url>/tool/email-anti-counterfeiting/</url><categories><category>工具</category></categories><tags><tag>email</tag></tags><content type="html"> 邮件是Web服务最常用通讯和身份验证手段。但因为邮件协议本身的问题，导致邮件是可以被伪造的。通过规范化的设置，可以最大程度的防止邮件被伪造。
邮件为什么可以伪造 许多互联网服务的业务本质上是现实业务的类比和延伸，电子邮件也是如此。梳理一下现实中的邮局是如何对邮件进行管理的。假设北京王先生需要向上海钱女士寄一封信，那么王先生需要在信封上写清楚自己的姓名地址和别人的姓名地址，贴上邮票塞入邮筒。北京邮局收集邮筒，确认邮票并盖邮戳，通过不同的交通方式将邮件送到上海邮局。上海邮局确认邮戳并将邮件分拣派送到钱女士的邮箱里面。对比一下电子邮件的发送方式。假设gmail用户a-user要给outlook用户b-user发一封邮件，那么a-user应该登录gmail，写对b-user的邮箱地址，写上内容，点击发送。gmail邮箱服务打上自己的“邮戳”再使用发件协议将这封信发送给outlook邮箱服务，outlook邮箱服务确认“邮戳”后将邮件放到b-user的邮箱账户中。
这波操作是不是非常方便完美。但是，一般来说，公司会购买两类邮箱服务。第一类是员工使用的办公邮箱，用来给内外部邮箱收发办公邮件。第二类是给程序使用的通知邮箱，用来给用户邮箱发送验证码等通知邮件。通知邮箱只发送邮件，注重于短时间大数量的邮件发送。办公邮箱注重邮件收发及账号管理。这两类邮箱都会自定义域名作为邮箱后缀，如：@baidu.com。如果邮箱域名可以自定义，则出现伪造的问题。比如我可以自己搭建一个邮箱服务器，给指定邮箱发送一封伪造邮件。说自己是@baidu.com的，你中了五百万大奖，只需要转账一万块钱手续费。
可以伪造的原因在于，SMTP协议（邮件发送协议）是一个透明的协议。作为邮件发送者可以指定SMTP发送者的发送账户、发送账户的显示名称、SMTP服务器域名等信息，如果接受端未对这些信息进行认证，就可能放过一些刻意伪造的邮件。再次类比邮局业务可以看问题出在了哪。发件方邮局的邮戳，收件方已经知道是什么样子。收件方再收件的时候，只需要判断信封上的邮戳是不是真的即可。
收件服务商的防伪造验证策略 如果我拥有baidu.com这个域名的控制权，则可以在域名的DNS上加几条公开的TXT声明。声明里面写上，我发邮件的服务器IP地址是多少多少，可以验证我自己签名的公钥是多少多少。然后使用声明公钥相对的私钥签名邮件，再用声明 …</content></entry></search>